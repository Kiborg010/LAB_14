using ClassLibrary1;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection.Metadata.Ecma335;
using System.Text;
using System.Threading.Tasks;
using static System.Runtime.InteropServices.JavaScript.JSType;

namespace LAB_12_2
{
    public class MyHashTable<T> where T : IInit, ICloneable, new()
    {
        public T[] tableValue; //Таблица со значениям
        //Эта таблица нужная для следующей ситуации. Имеем пустую изначальную таблицу. Предположим, мы добавили один элемент в хэш-таблицу.
        //Вычисляется индекс для расположения элемента. После чего элемент помещается по этому индексу. Теперь добавим ещё один такой же элемент.
        //Происходит коллизия. В нашем случае второй элемент добавляется с помощью открытой адресации.
        //То есть происходит поиск следующей пустой позиции, куда его можно записать. Он записывается.
        //Теперь попробуем удалить элемент. Помним, что этих элементов два.
        //Для удаления сначала запускается поиск элемента, который происходит с помощью вычисления хэш-кода и обращения по нужному индексу.
        //Понятное дело, удаление элемента в первый раз приведёт к удалению именно первого добавленного элемента из таблицы.
        //Но что будет, если запустить удаление элемента ещё раз? Мы снова считаем хэш-код искомого элемента. Обращаемся по индексу к таблице.
        //Понимаем, что под этим индексом элемента нет. Тогда программа нам скажет, что такого элемента в таблице нет, а значит и удалять больше ничего не надо.
        //Это даёт нам две проблемы: мы не всегда можем найти и удалить введённый элемент. Именно для решения этой проблемы создаётся таблица tableNextFactor.
        //Эта массив такой же длины, что и массив со значениями. И каждый элемент в первом массиве соотносится с элементом во втором массиве.
        //Если элемент удаляется, то в tableNextFactor в соответствующую позицию будет записано true. Что для последующей проверки означает: здесь был элемент, но был удалён, ищи дальше.
        //После чего цикл будет проходиться по всем остальным элементам таблицы, пока не будет найден или не найден.
        //Также есть другуая ситуация. Когда мы добавляем первый элемент, а потом второй(другой), но с таким же хэш-кодом. И если мы будем искать второй элемент, то мы его не найдём, потому что первый элемент занял индекс
        //Тогда можно записывать в тот же массив tableNextFactor в нужную позицию true ещё и в этом случае. То есть основная задача этого массива показать, что там дальше есть элемент с таким же хэш-кодом, и что есть смысл запускать перебор
        //Все эти случаи можно было особо и не рассматривать и просто запускать перебор всех элементов в таблице в любой непонятной ситуации, но лучше сократить такие ситцаии до минимума, потому что элементов может быть много, и делать перебор каждый раз не очень хорошо
        public bool[] tableNextFactor;
        public int count = 0; //Количество элементов в таблице
        public double fillRatio; //Коэффициент заполнения. При превышении соотношения количества и вместимости с этим коэффициентом, таблица будет увеличена вдвое.
        static string lineLong = new string('-', 150); //Просто строка для разделения вывода таблицы

        public int Capacity => tableValue.Length; //Свойство для вместимости таблицы
        public int Count 
        {
            get
            {
                return count;
            }
            set
            {
                count = value;
            }
        } //Свойство для количества элементов

        public MyHashTable(int size = 1, double fillRatio = 0.72) //
        {
            tableValue = new T[size];
            tableNextFactor = new bool[size];
            this.fillRatio = fillRatio;
        }

        public bool Contains(T data) //Метод для проверки содержания элемента
        {
            return !(FindItem(data) < 0); //Просто использует метод FindItem
        }

        int GetIndex(T data) //Метод для определения индекса
        {
            int hashCode = data.GetHashCode(); //Переменная для записи хэш-кода. Его вычисление зависит от типа data. Поэтому нужно рассматреть несколько случаев
            if (data is OffRoadCar)
            {
                OffRoadCar car = data as OffRoadCar;
                hashCode = (int)car.GetHashCode();
            }
            else if (data is PassengerCar)
            {
                PassengerCar car = data as PassengerCar;
                hashCode = (int)car.GetHashCode();
            }
            else if (data is LorryCar)
            {
                LorryCar car = data as LorryCar;
                hashCode = (int)car.GetHashCode();
            }
            else if (data is Car)
            {
                Car car = data as Car;
                hashCode = (int)car.GetHashCode();
            }
            return Math.Abs(hashCode) % Capacity; //Индекс зависит в основном от хэш-кода. Только он ещё делится по модулю вместимости таблицы
        }

        public int FindItem(T data) //Метод для поиска элемента в хэш-таблице
        {
            int index = GetIndex(data); //Для начала найдём индекс по которому возможно будет элемент
            if (data.Equals(tableValue[index])) //Самый простой вариант: под посчитанным индексом оказался элемент именно с тем содержанием, которое искалось
            {
                return index; //И возвращаем индекс
            }
            //Иной случай, когда под этим индекосм ничего нет
            else if (tableNextFactor[index] == true) //Если этот фактор true, то значит есть смысл искать элемент дальше в таблице
            {
                int current = index; //Создаём текущий индекс равным первому индексу
                int indexResult = -1; //Итоговый индекс - индекс по которому находится искомый элемент. Изначально -1 - то есть элемент пока не найден
                while (current < tableValue.Length && indexResult == -1) //Пока текущий индекс не дошёл до конца таблицы и итоговый индекс остаётся -1
                {
                    if (data.Equals(tableValue[current])) //Если элемент под текущим индексом совпадает с искомой информацией
                    {
                        indexResult = current; //То сохраняем текущий индекс в итоговый
                    }
                    else
                    {
                        current++; //Иначе увеличиваем индекс
                    }
                }
                if (indexResult == -1) //Если итоговый индекс остался -1
                {
                    current = 0; //Дошли до конца таблицы, ничего не нашли. Но может быть такое, что элемент находится в начале таблицы (то есть перед изначальным индексом)
                    while (current < index && indexResult == -1) //Пока текущий индекс не дойдёт до изначального индекса
                    {
                        if (data.Equals(tableValue[current])) //Если элемент под текущим индексом совпадает с искомой информацией
                        {
                            indexResult = current;//То возвращаем текущий индекс
                        }
                        else
                        {
                            current++;//Иначе увеличиваем индекс
                        }
                    }
                    if (indexResult != -1) //Итоговый индекс не -1 - возвращаем его
                    {
                        return indexResult;
                    }
                    else //Если итоговый индекс остался -1, то значит, что обыскали вообще всё, и не нашли - возвращаем -1. 
                    {
                        return -1;
                    }
                }
                else //Если итоговый индекс не -1, то возвращаем его.
                {
                    return indexResult;
                }
            }
            else //Если же фактор равен false, то значит, что элемент с таким же хэш-кодом дальше искать смысла нет
            {
                return -1;
            }

        }

        public bool RemoveData(T data) //Метод для удаления элемента по значению
        {
            int index = FindItem(data); //Определяем индекс элемента по искомой информации
            if (index < 0) //Если элемент не найден, возвращем false, то есть удаления не было
            {
                return false;
            }
            count--; //Иначе уменьшаем количество элементов
            tableValue[index] = default; //Обнуляем элемент по индексу
            tableNextFactor[index] = true; //И ставим маркер удаления на true
            return true; //Возвращаем true - удаление произошло
        }

        public void Print() //Метод для вывода таблицы
        {
            int i = 0; //У каждого элемента в хэш-таблице есть индекс, его тоже надо выводить, для этого и заводится переменная
            if (Count == 0) //Если количетсво элементов равно ноль, то выводим сообщение, что таблица пуста
            {
                Console.WriteLine("Таблица пуста");
            }
            else //В ином случае
            {
                foreach (T item in tableValue) //Перебираем элементы в массиве значений
                {
                    string message; //Переменная для сообщения
                    if (item is null) //Если элемент в таблице пустой
                    {
                        message = "<Пусто>"; //То соответсвующее сообщение
                    }
                    else
                    {
                        message = item.ToString(); //Иначе приводим элемент к строчному формату
                    }
                    Console.WriteLine(lineLong); //Выводим разделяющую строку
                    Console.WriteLine($"{i}: {message}"); //Выводим индекс элемента и сообщение с информаицей об элементе
                    i++; //Увеличиваем индекс
                }
            }
        }

        public void AddItem(T item1) //Первый метод для добавления элемента
        {
            T item = (T)item1.Clone();
            if (item != null) //Если добавляемый элемент пустой, то ничего не добавляем и просто прекращаем работу метода
            {
                if (tableValue.Contains(item)) //Нельзя добавлять элемент точно с такими же параметрами
                {
                    throw new Exception($"Такой элемент уже есть: \n{item.ToString()} \nОн добавлен не будет");
                }
                if ((double)Count / Capacity > fillRatio) //Смотрим степень заполнения таблицы. Если соотношение количества и вместимости больше, чем изначально заданный коэффициент заполнения
                {
                    T[] temp = (T[])tableValue.Clone(); //Клонируем массив значений
                    tableValue = new T[temp.Length * 2]; //Создаём новый массив значений, но в два раза больше предыдующей
                    tableNextFactor = new bool[temp.Length * 2]; //Аналогично для массива с информаицей об удалении 
                    count = 0; //Количетсов элементов обнуляем. В AddData всё равно количество восстановится
                    for (int i = 0; i < temp.Length; i++) //И перетаскиваем из предыдующей таблицы элементы в новую
                    {
                        AddData(temp[i], i);
                    }
                }
                AddData(item); //И добавляем элемент из-за которого всё и началось
            }
        }

        public void AddData(T data, int currentIndex = -1) //Второй метод для добавления метода элемента
        {
            if (data == null)
            {
                try
                {
                    tableValue[currentIndex] = data;
                }
                catch (Exception e)
                {
                    throw new Exception("Ошибка в добавлении пустого элемента");
                }
            }
            else
            {
                int index = GetIndex(data); //Находим индекс по которому должен находиться добавляемый элемент
                int current = index; //Создаём текущий индекс равный базовому
                if (tableValue[index] != null) //Если значение по начальному индексу не пустое (то есть произошла коллизия)
                {
                    tableNextFactor[index] = true; //Записываем в фактор true, то есть показываем, что дальше есть ещё один элемент с таким хэш-кодом
                                                   //Коллизию разрешаем открытой адресацией, то есть ищем первую свободную ячейку
                    while ((current < tableValue.Length) && (tableValue[current] != null))  //Пока текущий индекс не дошёл до конца и значение таблицы под этим индексом не пустой 
                    {
                        current++; //Увеличиваем текущий индекс
                    }
                    if (current == tableValue.Length) //Если текущий индекс дошёл до конца таблицы
                    {
                        current = 0; //То начинаем поиск пустого места с начала таблицы
                        while ((current < index) && (tableValue[current] != null)) //Ищем, пока не дойдём до начального индекса
                        {
                            current++; //Увеличиваем текущий индекс
                        }
                    }
                    if (current == index) //Если в итоге текущий индекс всё-таки дошёл до изначального индекса (в котором должен быть записан элемент), то делаем вывод, что всю таблицу перебрали и места не нашли
                    {
                        throw new Exception("Нет места в таблице"); //Тогда выкидываем соответствующий exception
                    }
                }
                tableValue[current] = data; //Если в итоге exception не получили, то в найденный свободный индекс записываем добавляемую информацию
                Count++; //Увеличиваем общее ко личество элементов в таблице
            }
        }
    }
}
